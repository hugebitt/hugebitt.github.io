{"posts":[{"title":"02. Variables","text":"안녕하세요. Dart 관련 tutorial code 는 Nomad Coder 의 “Dart 시작하기” 강의 내용을 참고하였음을 밝힙니다. Hello World Variables var 관습적으로나 함수나 메소드 내부에 지역 변수를 선언할 때에는 var 를 사용합니다. var1234void main() { var name = 'keunbit'; print(name);} class 에서 변수나 property를 선언할 때에는 타입을 지정해 줍니다. property1234void main() { String name = 'keunbit'; print(name);} 변수를 할당할 때 여러 타입의 value가 할당 될 수 있도록 하고 싶을 때는 dynamic 을 사용합니다. dynamic12345678void main() { dynamic name = 'keunbit'; print(name); name = 123; print(name); name = true; print(name);} final final 은 한 번 정의된 변수를 수정할 수 없게 만들고 싶을 때 사용합니다. final123456void main() { final name = 'keunbit'; print(name); name = 'keunbit2'; // 에러 발생. The final variable 'name' can only be set once. print(name);} late late 는 변수를 선언할 때 초기화를 하지 않고, 나중에 초기화를 하고 싶을 때 사용합니다. final 이나 var 앞에 붙여줄 수 있는 수식어 입니다. api 를 통해 받아온 데이터를 사용할 때 유용합니다. (Data fetching) late1234567void main() { late final String name; // do something, go to api name = 'keunbit'; print(name);} const dart 의 const 는 javascript 나 typescript 와는 조금 다른 개념입니다. javascript 나 typescript 에서 사용하는 const 는 dart 의 final 과 유사합니다. dart 에서 const 는 compile-time constant 입니다. 즉, 우리가 앱스토어 앱을 올리기 전에 알고 있는 값들을 const 로 선언해줍니다. const123void main() { const max_allowed_price = 120;} 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference “Dart 시작하기”","link":"/2023/01/14/programming/dart/dart_tutorial-02/"},{"title":"01. Why Dart?","text":"안녕하세요. 이번 Dart tutorial은 개인적으로 사이드 프로젝트를 진행하면서 공부한 내용을 정리할 겸 메모하는 용도로 작성하려고 합니다. 이번 사이드 프로젝트에서는 Flutter Language 로 App 개발을 진행할거라 이에 필요한 필수 지식인 Dart 부터 정리하려고 합니다. 우선 왜 Flutter 를 선택했는지에 대해서는 차근차근 내용을 업데이트 하도록 하겠습니다. Dart 관련 tutorial code 는 Nomad Coder 의 “Dart 시작하기” 강의 내용을 참고하였음을 밝힙니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference “Dart 시작하기”","link":"/2023/01/12/programming/dart/dart_tutorial-01/"},{"title":"Clean Code 작성법","text":"Intro안녕하세요. 예전애 유튜브채널 노마드코더에서 깨끗한 코드를 위한 5가지 팁 을 영상에서 본 후 Python 코드로 변환해서 개인적으로 저장한 것을 블로그에 작성하려고 합니다. 저의 경우 코딩을 할 때 스스로 가져야 할 마인드셋(?)으로 정리하고 있는데요. 공유하면 좋을 것 같아 포스팅 하게 되었습니다. 검색이 가능한 이름을 사용하자 함수명은 반드시 동사로 짧은 변수명이나 (아무도 이해못하는) 축약어는 피하자 함수는 단 한가지 기능만 수행하도록 boolean 값을 인수로 함수에 보내는 것을 최대한 방지하자 (물론 코딩스타일에는 정답은 없습니다.) Clean Code 5가지1. 검색이 가능한 이름을 사용하자변수 네이밍에 대한 것인데요. 다른 사람이 읽었을 때 바로 이해가 될 수 있도록 작성하자는 것입니다. 변수명123456*-- not good --*print(86400)*-- good --*seconds_in_a_day = 86400print(seconds_in_a_day) 2. 함수명은 반드시 동사로변수 네이밍을 잘 하는 것도 중요하듯, 우리가 정의할 함수에 대한 네이밍도 굉장히 중요합니다. 이 함수가 어떤 기능을 수행하는지 밑에 코드를 안보더라도 알 수 있도록 말이죠. 함수명12345678910*-- not good --*def user_data(): passdata = userData();*-- good --*def load_user_data(){ pass}user_data = load_user_data() 3. 짧은 변수명이나 (아무도 이해못하는) 축약어는 피하자함수의 파라미터에 대한 얘기입니다. 파라미터명1234567*-- not good --*def add_user_info(n,p): pass*-- good --*def add_user_info(name,phone_number): pass 4. 함수는 단 한가지 기능만 수행하도록하나의 함수에서 여러가지 기능을 수행하는 것을 되도록 피하자는 것입니다. 기능 단위로 최대한 쪼개서 작성해주는 것이죠. 함수 쪼개기12345678910111213141516171819202122232425262728293031323334353637383940import re*-- not good --*def load_user_data(name, email): check_email = re.compile('^[a-zA-Z0-9+-_.]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$') if check_email.match(email) == None: print('올바른 이메일 형식이 아닙니다') return False if len(name) &gt; 5: print('5글자 이하로 작성해주세요') return False # process user data pass*-- good --*def check_email(email): check_email = re.compile('^[a-zA-Z0-9+-_.]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$') return check_email.match(email)def check_name_length(name): if len(name) &gt; 5: return False else: return Truedef load_user_data(name, email): if check_email(email) == None: print('올바른 이메일 형식이 아닙니다') return False if check_name_length == False: print('5글자 이하로 작성해주세요') return False # process user data pass 지금처럼 함수를 기능별로 쪼개서 정의하는 것이 가독성도 좋아지고, 코드가 길면 길수록 유지/관리 측면에서 더 좋습니다. 5. boolean 값을 인수로 함수에 보내는 것을 최대한 방지하자boolean 값을 함수로 보낸다는 것은 그 함수에 if-else가 있다는 뜻이 됩니다. 차라리 각각의 케이스별로 함수를 분리하는 것이 좋습니다. 123456789101112131415161718192021222324*-- not good --*def send_message(text, is_private): if is_private: ## send private message pass else: ## send public message passsend_message(&quot;Hello&quot;, False)send_message(&quot;This is secret&quot;, True)*-- good --*def send_private_message(text): ## send private message passdef send_public_message(text): ## send public message passsend_public_message(&quot;Hello&quot;)send_private_message(&quot;This is secret&quot;) 결론이번 포스팅에서는 Clean Code 작성법 에 대해서 간단하게 정리해 봤습니다. 다시 한 번 말씀드리지만, 코드 작성에는 정답은 없습니다! 어떤 방법이 됐든, 누가 봐도 보기 쉽고 이해하기 편하게 작성하면 되는 것이니까요. 추가로!!! 개발을 시작할 때 처음부터 예쁘게 작성하려고 하기보다는 우선 모든 동작, 기능들을 구현한 후 클린 코드로 다듬어 주는 것도 좋은 순서 입니다!! 우선 이 주제는 여기까지 다뤄보도록 하겠습니다. 또 Pythonic 한 것은 또 느낌이 다르더라구요. Pythonic 한 파이썬 코딩에 대해서는 추후 더 깊게 다뤄보도록 하겠습니다 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference ‘노마드 코더’ Clean Code를 위한 5가지 팁 https://www.youtube.com/watch?v=Jz8Sx1XYb04","link":"/2022/03/23/programming/log/log-01/"},{"title":"Previous&#x2F;next post with category Filter","text":"Intro안녕하세요. 이번 포스팅에서는 현재 블로그에서 포스팅 밑에 이전글, 다음글 에 대해서 카테고리별로 표시될 수 있도록 커스터마이징 하는 방식에 대해 짧게 공유드리려 합니다. 기존에는 작성날짜를 기준으로 sorting이 되어있고, 포스트의 카테고리와는 무관하게 이전에 작성했던 글이 보이는 것이 마음에 걸려 하루(?)정도 삽질 끝에 해결하였습니다. 제가 사용하는 테마는 hexo-icarus-theme 라는 테마입니다. 버전은 5.1.1 을 쓰고 있습니다. 코드아래 코드 추가 라고 되어 있는 부분을 추가한 후에 렌더링되는 부분의 변수명도 바꿔주면 됩니다. /icarus/layout/common/article.jsx123456789101112131415161718192021222324252627282930313233343536373839404142module.exports = class extends Component { render() { const { config, helper, page, index } = this.props; const { article, plugins } = config; const { url_for, date, date_xml, __, _p } = helper; const indexLaunguage = toMomentLocale(config.language || 'en'); const language = toMomentLocale(page.lang || page.language || config.language || 'en'); const cover = page.cover ? url_for(page.cover) : null; const updateTime = article &amp;&amp; article.update_time !== undefined ? article.update_time : true; const isUpdated = page.updated &amp;&amp; !moment(page.date).isSame(moment(page.updated)); const shouldShowUpdated = page.updated &amp;&amp; ((updateTime === 'auto' &amp;&amp; isUpdated) || updateTime === true); /// 이 부분 코드 추가 let nextPage = page.next; let prevPage = page.prev; if (page &amp;&amp; nextPage &amp;&amp; prevPage) { if (page.categories.length &gt; 0) { const currentCategory = page.categories.data[1].name; while (nextPage.categories.data[1].name !== currentCategory &amp;&amp; nextPage.next) { nextPage = nextPage.next; } if (prevPage.categories.data.length &lt; 1) { prevPage = page.prev; } else { while (prevPage.categories.data[1].name !== currentCategory &amp;&amp; prevPage.prev) { prevPage = prevPage.prev; if (prevPage.categories.data.length &lt; 1) { prevPage = page.prev; break; } } } } else { nextPage = null; prevPage = null; } } /// 이 부분 코드 추가 return &lt;Fragment&gt;(렌더링 코드...)&lt;/Fragment&gt;; 그리고 렌더링 되는 부분도 마찬가지로 수정 return() page.next , page.prev 변경123456789101112131415161718192021222324252627282930{ !index &amp;&amp; (prevPage || nextPage) ? ( &lt;nav class=&quot;post-navigation mt-4 level is-mobile&quot;&gt; {nextPage ? ( &lt;div class=&quot;level-start&quot;&gt; &lt;a class={`article-nav-next level level-item${ !nextPage ? ' is-hidden-mobile' : '' } link-muted`} href={url_for(nextPage.path)}&gt; &lt;i class=&quot;level-item fas fa-chevron-left&quot;&gt;&lt;/i&gt; &lt;span class=&quot;level-item&quot;&gt;{nextPage.title}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; ) : null} {prevPage ? ( &lt;div class=&quot;level-end&quot;&gt; &lt;a class={`article-nav-prev level level-item${ !prevPage ? ' is-hidden-mobile' : '' } link-muted`} href={url_for(prevPage.path)}&gt; &lt;span class=&quot;level-item&quot;&gt;{prevPage.title}&lt;/span&gt; &lt;i class=&quot;level-item fas fa-chevron-right&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; ) : null} &lt;/nav&gt; ) : null;} 추가 설명을 더 해보자면 1nextPage.categories.data[1]; 여기서 인덱스 값을 1을 준 이유는, 각자의 블로그 카테고리의 level을 어떻게 설정 했느냐에 따라 다르게 설정해주면 될 것 같습니다. 저는 Programming &gt; Python 여기서 Python 카테고리만 걸러주기 위해 1 이라는 인덱스 값을 준 것입니다. 도움이 되셨길 바랍니다!!!. 혹은, 더 좋은 방법이 있다면 댓글 남겨주시면 감사하겠습니다!!! Reference https://github.com/hexojs/hexo/issues/2270","link":"/2023/01/13/programming/log/log-02/"},{"title":"00. 파이썬 개발환경","text":"안녕하세요. 이전 포스팅 은 우리가 왜(Why) 파이썬을 하는지를 주제로 얘기를 해봤는데요. 이번 포스팅은 Python 을 본격적으로 시작하기 전에 어떤것들을 다룰 것인지 먼저 말씀드리고자 합니다. 우선 저는 앞으로 다룰 내용을 크게 세가지로 나눠서 단계별로 다루려고 합니다. (여기서 나누는 기준은 단지 제가 지금까지 Pyhton을 다뤄보면서 느꼈던 순수히 저의 기준에서 나눈 것임을 말씀드립니다.) Step 1 메모리와 변수에 대한 개념, 그리고 자료형, 연산, 기초 문법(반복문, 조건문) 등… Step 2 함수(Function), 클래스(Class), 모듈(Module) 등… Step 3 병렬처리, 데코레이터, 패키지 빌드, Pythonic한 코딩 등… Step + 추가 꿀팁, 공유하면 좋을 기능들 등… (수시로 짧게 포스팅 예정) 그리고 파이썬 프로그래밍을 위한 “개발환경” 세팅(설치)에 대해서는 다루지 않을 예정입니다. (이미 많은 분들이 너무나도 잘 정리 해주신 자료가 많기때문에…) 대신 “개발환경” 에 대해서 잠깐 짚고 넘어가겠습니다. 크게 3가지로 구성되었다고 할 수 있을 것 같은데요. 운영체제 (Operating System, OS) Python Interpreter 코드 편집기 (Editor) 이 3가지에 대해서 각각이 무엇이고 어떤 것들이 있는지를 먼저 알고 넘어가면 좋을 듯 합니다. 운영체제 (Operating System, OS)운영체제는 많이 들어보셨을 것 같습니다. 대표적으로 Winodw, Mac, Ubuntu(Linux) 가 있습니다. 아마 코딩을 처음 입문 하시는 분은 대부분 Window 혹은 Mac 이겠죠. Ubuntu(Linux)에 대해서는 Reference 참고하시면 좋을듯 합니다. 여기서는 ‘지금 내 개발환경에서의 OS 는 이거구나’ 정도로 이해하고 넘어가겠습니다. Python InterpreterPython Interpreter 는 대표적으로 Python, Anaconda(or Miniconda) 이 있습니다. (저는 Anaconda를 사용합니다) 음...? Python Interpreter가 Python 이라는건 무슨 말이지? 싶을 텐데요. 여기서 인터프리터란, 인터프리터(Interpreter)는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 원시 코드를 기계어로 번역하는 컴파일러와 대비된다. -위키백과- 결국, 우리가 앞으로 작성할 소스코드를 동작할 수 있게 해주는 프로그램인데, 우리가 지금 Python 을 할 것이기 떄문에 Python Interpreter라고 한 것입니다. 만약 JavaScript 에 대해서 다뤘다면, JavaScript Interpreter라고 적었겠죠. 그리고 마지막에 “컴파일러와 대비된다” 라는 설명이 있는데요. 인터프리터와 컴파일러의 차이는 인터프리터는 개발 편의성이 높지만, 실행 속도는 느리다. (Python, JavaScript, Ruby,...) 컴파일러는 개발 편의성은 떨어지지만, 실행 속도는 빠르다. (Java, C, C++,...) 우선 이정도까지만 정리하겠습니다. 더 자세한 설명은 Reference 참고하시면 좋을듯 합니다. 저는 Anaconda 를 사용하고 있습니다. 그 이유는 가상환경(virtual env) 구성이 쉽다. (프로젝트 별 필요 라이브러리를 적절히 구성하기 용이함) 모듈 별 디펜던시(dependency)를 알아서 관리해준다. (버전 업데이트에서 생기는 기존에 설치된 모듈과의 충돌 방지해줌) 위 장점에 대해서 따로 더 설명하진 않겠습니다.(아마 직접 개발하시면서 몸으로 느끼게 될 거라고 생각합니다) 코드 편집기 (Editor)마지막으로 에디터 인데요. 말그대로 우리가 Python 이라는 언어를 작성하고 수정하는 행위들을 할 수 있도록 돕는 도구 입니다. 좋은 에디터 일수록, 개발자를 잘 서포팅(?)해주고, 코딩을 수월하게 할 수 있게 도와줍니다. 대표적으로는 Pycharm, Visual Studio Code, Jupyter Notebook(or Lab), Sublime Text, Atom 등 다양한데요. 보통 개인이 선호하는걸 사용합니다. (저는 Visual Studio Code 를 주로 사용하고 있습니다 ^^) 결론이번 포스팅에서는 Python 을 본격적으로 시작하기에 앞서 단계별로 어떤 것을 다룰 것인지, 그리고 개발환경에 대해서 얘기를 해봤는데요. 개발환경은 운영체제, 인터프리터, **에디터**로 구성되고 개발자는 에디터를 통해 소스코드를 작성하고(Python 문법에 맞게) 인터프리터가 코드를 읽고 실행시켜준다로 요약해볼 수 있을 것 같습니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference 파이썬 개발 로드맵 https://roadmap.sh/python 리눅스와 우분투 정리 글 https://hanamon.kr/리눅스는-무엇이고-우분투는-무엇인가/ 인터프리터와 컴파일러 차이 https://velog.io/@jaeyunn_15/OS-Compiler-vs-Interpreter","link":"/2022/03/15/programming/python/python-00/"},{"title":"01. 변수와 메모리","text":"안녕하세요. 이전 포스팅 에서는 우리가 Python 코딩을 하기 위한 개발환경을 이루는 요소들에 대해서 다루면서 OS, 인터프리터, 에디터 에 대해서 얘기를 해봤는데요. 이번 포스팅 부터는 본격적으로 Python 코딩에 대해서 시작하겠습니다. 혹시 본인 노트북에 개발환경세팅을 하는것에 어려움이 있었다면, Google 에서 제공하는 Colab 을 이용해서 코딩을 해보시는 것을 추천합니다. Google Colab 은 클라우드 기반의 무료 Jupyter Notebook 에디터 형태로 Python 스크립트를 작성하고 실행할 수 있는 개발환경 입니다. Colab에 대해서 잘 정리된 글과 Colab URL은 Reference에 적어두겠습니다. 변수와 메모리우선 변수와 메모리 에 대해서 개념을 짚고 넘어가겠습니다. 12name = &quot;keunbit&quot;print(name) keunbit 자, 위 코드를 봤을 때 감각적으로 이해가 되시지 않나요? Python 이라는 언어가 굉장히 배우기 쉽고 개발자 친화적 이라고 설명드린 이유입니다. 저 한 줄을 읽었을 때 이정도 의미로 생각할 수 있겠네요. name은 keunbit이다 name과 keunbit은 같다 name을 keunbit으로 정의한다. 좀 더 개발자(?)스럽게 생각을 해보죠, “name이라는 변수에 “keunbit”이라는 값을 할당한다” 라고 얘기하는게 맞습니다. (정확하게 설명하자면, 문자열 타입의 Object를 만들어서 name이라는 변수가 그 Object를 가리키는 것 입니다.) - Everything is object in Python - 중요한 것은 가리킨다 라는 의미인데요. 좀 더 예시를 들어보겠습니다. 123name = &quot;keunbit&quot;print(&quot;keubit 이라는 str Object를 만들고&quot;)print(f&quot;변수 'name'이 가르키는 주소는 {id(name)} 입니다.&quot;) keubit 이라는 str Object를 만들고 변수 'name'이 가르키는 주소는 140342633259056 입니다. 1234name1 = name2 = 'daehwan'print(&quot;daewhan 이라는 str Object를 만들고&quot;)print(f&quot;변수 name1이 이 Object를 가르킵니다. 주소는 {id(name1)} 입니다.&quot;)print(f&quot;변수 name2이 이 Object를 가르킵니다. 주소는 {id(name2)} 입니다.&quot;) daewhan 이라는 str Object를 만들고 변수 name1이 이 Object를 가르킵니다. 주소는 140342098563568 입니다. 변수 name2이 이 Object를 가르킵니다. 주소는 140342098563568 입니다. 위 코드를 그림으로 표현하면 다음과 같이 표현할 수 있습니다. 네 그림을 보시면 조금은 이해가 되실 것 같은데요. 그러면 변수를 선언하고 정의하는 과정은 이해가 되셨을테니, 변수 네이밍에 대한 얘기를 하겠습니다. 저는 지금 예시를 들면서 변수를 name, name1, name2 라고 네이밍을 했는데요. 몇가지 rule이 있습니다. 피해야 피해야 하는 rule1234561. 특별한 의미가 있는 `예약어`는 쓰지 않는다 - ex) for, if, else 등...2. %,!,@ 등 특수문자를 사용하지 않는다 - ex) !name, @name, name# 등...3. 숫자를 맨 앞에 쓰지 않는다. - ex) 1name, 2name, 등... 고려하면 좋은 rule12341. 의미 있는 단어로 표기하는 것이 좋다 (다른 사람이 봤을 때 무엇을 뜻하는지를 바로 알 수 있도록!) - ex) close_price, open_price2. 언더바(_)를 활용해서 작성해도 좋다 - ex) my_name 결론변수명을 짓는 것은 간단해 보이지만 사실은 굉장히 중요한 일 중 하나 입니다. 나중에 다루겠지만, 함수명을 작성하는 것 또한 매우 중요한데요. 네이밍을 잘 지을수록 협업하는 사람과의 코드 공유가 잘되고 커뮤니케이션이 잘 될 수 있기 때문입니다. 앞으로 개발 연습을 하시면서, 변수 네이밍도 신경을 쓰면서 작성하시는 것을 추천합니다. 데이터 타입 도 이번 글에 포함하려 했지만, 굉장히 중요한 내용이기에 다음 포스팅에서 좀 더 자세히 다루면 좋을 것 같습니다. 다음 포스팅을 보시면 위에서 언급했던 str 그리고 Object가 무엇인지 이해가 되실 것 같습니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference Google Colab 줏호 https://colab.research.google.com/?hl=ko Colab 개념 정리 https://theorydb.github.io/dev/2019/08/23/dev-ml-colab/ 구글 파이썬 스타일 가이드 https://google.github.io/styleguide/pyguide.html#316-naming","link":"/2022/03/17/programming/python/python-01/"},{"title":"02. 자료형과 연산","text":"안녕하세요 이전 포스팅 애서는 우리가 변수를 선언하면 ‘Everythin is object in Python’ 에 따라 객체를 생성하고 변수는 그것을 가르킨다 라고 정리했었습니다. 그런데 객체(Object)라는 것도 type 이 존재합니다. 이번 포스팅에서는 어떤 type이 있는지, 그리고 간단한 연산에 대해서 얘기해보겠습니다. 기본 자료형 (Data Type) : Integer, Float, String, Boolean 기본 연산자 : +,-,*,/,... 숫자형 - 정수형(Integer), 실수형(Float) 수학에서 정수는 양의 정수, 음의 정수 및 0으로 이루어진 수의 체계이다. 수학에서 실수는 주로 실직선 위의 점 또는 십진법 전개로 표현되는 수 체계이다. - 위키독스 - 네, 위키독스에서 나온 정의를 인용하며 더 설명하진 않겠습니다. 정수형1234a = 1a = -12a = 0print(type(a)) &lt;class 'int'&gt; 실수형1234a = 1.0a = -1.2a = 1.23E10print(type(a)) &lt;class 'float'&gt; 대신 여기서 앞에 class가 붙은 것에 대해서 잠깐 짚고 넘어가겠습니다. 이전 포스팅에서도 그렇고 이번 글의 시작에 파이썬에서는 ‘객체를 생성하고 변수는 그것을 가르킨다’ 라고 했습니다. 즉, tpye(a)를 print() 해서 나온 결과가 ‘int Object’가 생성 되었음 또는 ‘float Object’가 생성 되었음 그리고 a 라는 변수가 해당 Object를 가르키고 있는 것입니다. 그럼 저기 보이는 class가 무엇인지에 대해서는 이후 포스팅에서 class와 모듈 주제로 더 자세히 다뤄보겠습니다. 우선은 객체 라고 해두죠. 문자형(String) 문자, 단어 등으로 구성된 문자들의 집합을 의미한다. -위키독스- 우선 문자열을 만드는 방법에는 3가지가 있습니다. “,’,””” 이 표현들로 감싸주는 것입니다. 실수형123456a = &quot;1.0&quot;print(f&quot;변수 a는 {a} 이고 타입은 {type(a)} 입니다.&quot;)a = '1'print(f&quot;변수 a는 {a} 이고 타입은 {type(a)} 입니다.&quot;)a = &quot;&quot;&quot;Everything is Object in Python&quot;&quot;&quot;print(f&quot;변수 a는 {a} 이고 타입은 {type(a)} 입니다.&quot;) 변수 a는 1.0 이고 타입은 &lt;class 'str'&gt; 입니다. 변수 a는 1 이고 타입은 &lt;class 'str'&gt; 입니다. 변수 a는 Everything is Object in Python 이고 타입은 &lt;class 'str'&gt; 입니다. 위 예시를 봤을 때 1.0 하고 1 은 정수나 실수형 아닌가? 하는 의문이 드실텐데요. 일부로 이런 예시를 넣어봤습니다. 즉, 문자열로 정의하는 것은 “,’,””” 이 표현들로 감싸져있느냐가 핵심입니다. 문자열에 대해서는 여기서 끝내기 아쉬우니, ””” 는 언제사용하는지에 대해서 짧게 설명하고 넘어가겠습니다. 함수에 대한 설명을 작성할 때 큰 따옴표(“”)와 작은 따옴표(‘’)가 존재하는 텍스트를 다룰 때 1번은 나중에 함수를 주제로 포스팅할 때 자연스럽게 설명드리게 될 것 같고, 2번에 대해서 간단하게 예시를 보여드리겠습니다. 문자형1a = '이 글에는 &quot;큰 따옴표&quot;와 '작은 따옴표'가 존재합니다' SyntaxError: invalid syntax 문자형1a = &quot;이 글에는 &quot;큰 따옴표&quot;와 '작은 따옴표'가 존재합니다&quot; SyntaxError: invalid syntax 문자형123a = &quot;&quot;&quot;이 글에는 &quot;큰 따옴표&quot;와 '작은 따옴표'가 존재합니다&quot;&quot;&quot;a = '''이 글에는 &quot;큰 따옴표&quot;와 '작은 따옴표'가 존재합니다''' # ''' 으로도 사용 가능합니다 ^^print(a) 이 글에는 &quot;큰 따옴표&quot;와 '작은 따옴표'가 존재합니다 논리형(Boolean) 참(True)과 거짓(False)을 나타내는 자료형이다. 2가지 값만 가질 수 있다. True, False는 파이썬의 예약어로 ture, false가 아닌 첫 문자를 항상 대문자로 정의하여야 한다 -위키독스- 논리형1234a = Trueb = Falseprint(type(a))print(type(b)) &lt;class 'bool'&gt; &lt;class 'bool'&gt; 논리 자료형에서는 어떤 케이스에서 ‘True’, ‘False’ 라고 판단하는지를 위주로 알아보겠습니다. 논리형 예시1234567891011121314a = 1b = 1print(f&quot;a = 1, b = 1의 bool은 {a == b}&quot;)print(f&quot;1 &gt; 2의 bool은 {1 &gt; 2}&quot;)print(f&quot;1 &lt; 2의 bool은 {1 &lt; 2}&quot;)print('-'*20)a = &quot;&quot;print(f&quot;a = ''일 때 bool은 {bool(a)}&quot;)a = Noneprint(f&quot;a = None일 때 bool은 {bool(a)}&quot;)a = []print(f&quot;a = []일 때 bool은 {bool(a)}&quot;)a = [1]print(f&quot;a = [1]일 때 bool은 {bool(a)}&quot;) a = 1, b = 1의 bool은 True 1 &gt; 2의 bool은 False 1 &lt; 2의 bool은 True -------------------- a = ''일 때 bool은 False a = None일 때 bool은 False a = []일 때 bool은 False a = [1]일 때 bool은 True 자 위 코드 결과에 대해서 짧게 설명을 드려보자면수학기호 =, &gt;, &lt; 은 설명안해도 잘 아실 것 같으니 넘어가겠습니다. 변수에 대해서 “참,거짓”을 판단할 때 요소(attributes)가 없다면 False 결과를 내고있음을 알 수 있습니다. 다음 포스팅에서 다루겠지만, [] 를 ‘리스트 자료형’이라고 하는데요. a = [1] 처럼 1이라는 정수형 요소가 하나 존재할 때는 True를 뱉지만, a = []처럼 비어있을 경우 False를 내뱉는 것을 알 수 있습니다. 연산자 다루기이제 연산자에 대해서 얘기해보죠. 비교적 간단합니다. 숫자형 연산자 예시123456789101112a = 1b = 2print(f'더하기 연산 a + b = {a+b}')print(f'빼기 연산 a - b = {a-b}')print(f'곱하기 연산 a * b = {a*b}')print(f'나누기 연산 a / b = {a/b}')print('-'*20)a = 5b = 2print(f'제곱 연산 a ** b = {a**b}')print(f'나머지 연산 a % b = {a%b}')print(f'몫 연산 a // b = {a//b}') 더하기 연산 a + b = 3 빼기 연산 a - b = -1 곱하기 연산 a * b = 2 나누기 연산 a / b = 0.5 -------------------- 제곱 연산 a ** b = 25 나머지 연산 a % b = 1 몫 연산 a // b = 2 네 기본 연산에 대한 예시를 들어보았습니다. 그리고 데이터를 다루다보면 한 번 선언한 변수를 반복적으로 1씩 더해주거나 빼주거나 하는 경우가 존재합니다. 숫자형 연산자 예시2123456789101112131415161718192021222324252627a = 5a = a + 1print(f'a = a+1 결과는 {a}')a = 5 # 예시를 위해 다시 선언a += 1print(f'a += 1 결과는 {a}')a = 5a -= 1print(f'a -= 1 결과는 {a}')a = 5a /= 2print(f'a /= 2 결과는 {a}')a = 5a **= 2print(f'a **= 2 결과는 {a}')a = 5a //= 2print(f'a //= 2 결과는 {a}')a = 5a %= 2print(f'a %= 2 결과는 {a}') a = a+1 결과는 6 a += 1 결과는 6 a -= 1 결과는 4 a /= 2 결과는 2.5 a **= 2 결과는 25 a //= 2 결과는 2 a %= 2 결과는 1 위와 같이 작성하는 것은 ‘아 이렇게도 작성해서 연산할 수 있구나’ 정도로만 알아두면 좋을 것 같네요. 문자형에도 연산자를 사용할 수 있는데요. 예시를 들어보죠. 문자형 연산자 예시123456a = &quot;You&quot;b = &quot;need&quot;c = &quot;Python&quot;print(f&quot;문자열 더하기 {a + b + c}&quot;)print(f&quot;문자열에 숫자 곱하기 {c*2}&quot;)print(f&quot;문자열 길이 구하기 {len(c)}&quot;) 문자열 더하기 YouneedPython 문자열에 숫자 곱하기 PythonPython 문자열 길이 구하기 6 문자열을 더하기(Concatenation) 와 곳셈연산자를 통해 표현하는 것과, 문자열의 길이를 구하는 내장 함수인 len()에 대해서 알아보았습니다. 결론이번 포스팅에서는 자료형(Integer, Float, String, Boolean)에 대해서 어떤 것들인지를 알아보았고, 연산자를 어떻게 활용할 수 있는지에 대해서 정리해 봤습니다. 다음 포스팅은 리스트(List), 튜플(Tuple), 딕셔너리(Dictionary), 셋(Set) 자료형에 대해서 다뤄보겠습니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference 점프 투 파이썬 https://wikidocs.net/12","link":"/2022/03/18/programming/python/python-02/"},{"title":"03. 리스트(List), 튜플(Tuple), 딕셔너리(Dictionary), 셋(Set)","text":"안녕하세요 이전 포스팅 애서는 Pyhton 의 기본 자료형과 연산에 대해서 얘기를 나눠봤습니다. 이번 포스팅에서는 실제 데이터를 핸들링 하기 위해 필수적으로 알아야 할 리스트, 튜플, 딕셔너리, 셋(집합) 형태의 데이터들 특징과 어떻게 핸들링 하는지에 대해서 다뤄보겠습니다. 리스트, 튜플, 딕셔너리, 셋 의 특징 정리 Mutable vs Immutable 정리 Orderded vs Unordered 정리 리스트, 튜플, 딕셔너리, 셋(집합) 만들기일단 여러가지 케이스로 만들어 보고, 특징을 파악해 보겠습니다. 리스트(List) 예시123456empty_list = []empty_list = list()int_list = [1, 2, 3, 4]name_list = ['name_a', 'name_b', 'name_c', 'name_d']int_name_list = [1, 'name_a', 2, 'name_b', 3, 'name_c', 4, 'name_d']list_in_list = [1, 2, 3, ['name_a', 'name_b', 'name_c']] 튜플(Tuple) 예시1234567empty_tup = ()empty_tup = tuple()one_tup = (1,) # 콤마 붙여줘야 함name_tup = ('name_a', 'name_b', 'name_c', 'name_d')name_tup2 = 'name_a', 'name_b', 'name_c', 'name_d'int_name_tup = (1, 'name_a', 2, 'name_b', 3, 'name_c', 4, 'name_d')tup_in_tup = (1, 2, 3, ('name_a', 'name_b', 'name_c')) 딕셔너리(Dictionary) 예시123456empty_dict = {}empty_dict = dict()example_dict = {'name': 'keunbit', 'blog_addr': 'https://keunbit.blog/', 'born_year': 1994}key_int_dict = {1: 'You', 2: 'need', 3: 'Python'}lang_dict = {'lang_list': ['Python', 'JavaScript'], 'lang_tup': ('Python', 'JavaScript')}dict_in_dict = {'name': 'keunbit', 'born_year': 1994, 'more': {'blog': 'https://keunbit.blog/', 'github': 'https://github.com/keunbit'}} 셋(Set) 예시1234567891011empty_set = set()example_set = set('Python')list_to_set = set([1, 2, 3, 4])tuple_to_set = set(('name_a', 'name_b', 'name_c', 'name_d'))dict_to_set = set({'name': 'keunbit', 'blog_addr': 'https://keunbit.blog/', 'born_year': 1994})print(f&quot;empty_set =&gt; {empty_set}&quot;)print(f&quot;example_set =&gt; {example_set}&quot;)print(f&quot;list_to_set =&gt; {list_to_set}&quot;)print(f&quot;tuple_to_set =&gt; {tuple_to_set}&quot;)print(f&quot;dict_to_set =&gt; {dict_to_set}&quot;) empty_set =&gt; set() example_set =&gt; {'h', 'n', 't', 'y', 'o', 'P'} list_to_set =&gt; {1, 2, 3, 4} tuple_to_set =&gt; {'name_b', 'name_a', 'name_d', 'name_c'} dict_to_set =&gt; {'born_year', 'blog_addr', 'name'} 우선 여기까지 각각의 특징을 한 번 보겠습니다. 리스트 list() 로 비어있는 리스트를 선언할 수 있다 대괄호 []로 감싸 주고 각 요소들은 콤마 ,로 구분한다. 리스트에 저장되는 요소들은 어떠한 자료형도 포함시킬 수 있다. 튜플 tuple() 로 비어있는 튜플을 선언할 수 있다. 소괄호 ()로 감싸 주고 각 요소들은 콤마 ,로 구분한다. 단 1개의 요소만 가질 때는 요소뒤에 콤마 ,를 반드시 붙여야 한다. 변수에 선언할 때 괄호가 없어도 튜플 형태로 선언할 수 있다. 딕셔너리 dict() 로 비어있는 딕셔너리를 선언할 수 있다. {Key1: Value1, Key2: Value2, Key3, Value3, …} 처럼 Key와 Value의 쌍 여러개가 {}로 둘러싸여 있다. Key에는 변하지 않는 값이며 중복될 수 없다. 반면에 Value는 변하지 않는 값을 사용할 수 있다. Value에는 Tuple과 List 자료형 그리고 Dictionary를 넣을 수 있다. 셋(집합) set() 로 비어있는 셋을 선언할 수 있다. 중복을 허용하지 않는다. 순서가 없다. (Python -&gt; h, n, t, y, o , P 로 들어감) 우선 위 코드 예시로는 저정도 특징을 알 수 있을 것 같은데요. 좀 더 중요한 얘기를 해보겠습니다. 리스트, 튜플, 딕셔너리, 셋 에 대해서 중요한 몇가지 관점 에서 비교해 보겠습니다. Ordered(순서 있음) vs Unordered(순서 없음)순서의 유무가 무슨 의미이지 싶으실텐데요. 데이터를 조회(찾기) 할 때 차이가 있습니다. 순서가 있으면 인덱싱, 슬라이싱 으로 데이터를 조회할 수 있다. 단, Dictionary의 경우 Hash Table 이기 때문에 key값을 통해 데이터를 가져온다. (List, Tuple, Dictionary) 순서가 없으면 인덱싱, 슬라이싱 은 불가능하기 때문에, list, tuple로 변환 후 조회할 수 있다. (Set) Ordered - 인덱싱과 슬라이싱(List, Tuple)인덱싱과 슬라이싱에 대해서 잠깐 짚고 넘어가겠습니다. 리스트, 튜플 인덱싱과 슬라이스1234567list_sample = [1, [2, 3], 4, 5]tuple_sample = (6, 7, (8, 9), 10)print(f&quot;list_sample의 0의 인덱스 값은 list_sample[0] {list_sample[0]}&quot;)print(f&quot;list_sample의 마지막 인덱스 값은 list_sample[-1] {list_sample[-1]}&quot;)print(f&quot;tuple_sample의 1의 인덱스 값은 tuple_sample[1] {tuple_sample[1]}&quot;)print(f&quot;list_sample의 0~3 인덱스 값은 list_sample[0:3] {list_sample[0:3]}&quot;)print(f&quot;tuple_sample의 뒤에서 2번째부터 끝까지 인덱스 값은 tuple_sample[-2:] {tuple_sample[-2:]}&quot;) list_sample의 0의 인덱스 값은 list_sample[0] 1 list_sample의 마지막 인덱스 값은 list_sample[-1] 5 tuple_sample의 1의 인덱스 값은 tuple_sample[1] 7 list_sample의 0~3 인덱스 값은 list_sample[0:3] [1, [2, 3], 4] tuple_sample의 뒤에서 2번째부터 끝까지 인덱스 값은 tuple_sample[-2:] ((8, 9), 10) 여기서 정리할 수 있는 것은 Python은 0부터 숫자를 세기 때문에 첫번째 0요소를 조회할 땐 인덱스 값을 0으로 해야 한다는 것입니다. 슬라이싱은 : 기호를 사용해서 특정 인덱스:인덱스 를 통해 특정 범위의 데이터를 조회할 수 있습니다. Ordered - Key값으로 조회(Dictionary)자 그럼 순서가 없는 딕셔너리와, 셋은 어떻게 조회할까요? 딕셔너리 데이터 조회하기123dict_sample = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}print(dict_sample['key1'])print(dict_sample[0]) # 에러 value1 ----&gt; 4 print(dict_sample[0]) KeyError: 0 딕셔너리의 경우는 key 값을 통해서 value1의 값을 조회하였습니다. 반면에 인덱스 형태로 0의 값을 주어 찾으려고 하게 되면 keyError라는 에러 메시지를 띄우게 됩니다. 위에서 Hash 를 통해 데이터를 조회한다고 했는데요. 이렇게 자료구조를 해쉬 방식으로 저장하게 되면, 나중에 데이터를 조회할 때 속도 측면에서 굉장한 장점을 가지게 됩니다. Unoreded - 리스트,튜플로 변환 후 조회(Set)셋 데이터 조회하기1234set_sample = {1, 2, 3, 4, 5}print(list(set_sample)[1])print(tuple(set_sample)[2])print(set_sample[1]) # 에러 2 3 ----&gt; 4 print(set_sample[1]) TypeError: 'set' object is not subscriptable 셋(Set)의 경우 List, Tuple 형태로 변환 후 인덱스 값을 주어 찾아야 합니다. Mutable(가변성) vs Immutable(불변성)의 관점가변성이란 말그대로 요소의 값이 변경할 수 있다. 즉, 수정(어데이트)이 가능하다 라는 의미입니다. (그런데 요소를 추가하는 것은 또 다른 얘기입니다) 튜플은 Immutable / 리스트, 딕셔너리, 셋 은 Mutable 합니다. 먼저 Mutable한 것부터 보겠습니다. Mutable 하기때문에 추가, 수정, 삭제 등의 기능을 제공합니다. Mutable - 추가리스트123456789list_sample = [1, 2, 3, 4, 5]list_sample.append(6)print(list_sample)list_sample.extend([7,8,9]) # Nest 하게 추가하는 방법print(list_sample)list_sample.append([10,11,12]) # list 그대로 추가됨print(list_sample)list_sample += [13, 14, 15] # list 그대로 추가됨print(list_sample) [1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 2, 3, 4, 5, 6, 7, 8, 9, [10, 11, 12]] [1, 2, 3, 4, 5, 6, 7, 8, 9, [10, 11, 12], 13, 14, 15] extend() 함수와 append() 예시 주목해보면 좋을 것 같습니다. 셋12345set_sample = {6, 7, 8, 9, 10}set_sample.add(11)print(set_sample)set_sample.update([12, 13, 14]) # 여러개 추가할 때 update를 사용print(set_sample) {6, 7, 8, 9, 10, 11} {6, 7, 8, 9, 10, 11, 12, 13, 14} 딕셔너리12345dict_sample = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}dict_sample['key4'] = 'value4'print(dict_sample)dict_sample.update({'key5': 'value5', 'key6': 'value6'}) # 여러개 추가print(dict_sample) {'key1': 'value1', 'key2': 'value2', 'key3': 'value3', 'key4': 'value4'} {'key1': 'value1', 'key2': 'value2', 'key3': 'value3', 'key4': 'value4', 'key5': 'value5', 'key6': 'value6'} 여러개를 추가할 때 update() 함수를 사용하며 셋의 경우 추가할 요소들을 []로 감싸는 것 과 딕셔너리의 경우 같은 {} 안에 key: value 형태를 맞춰서 넣어 주고 있다는 것을 주목해볼 필요가 있겠네요. Mutable - 수정리스트123list_sample = [1, 2, 3, 4, 5]list_sample[1] = 6print(list_sample) [1, 6, 3, 4, 5] 셋의 경우 데이터를 수정하는 기능은 없습니다. 딕셔너리12345dict_sample = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}dict_sample['key1'] = 'value4'print(dict_sample)dict_sample.update({'key2': 'value5', 'key3': 'value6'})print(dict_sample) {'key1': 'value4', 'key2': 'value2', 'key3': 'value3'} {'key1': 'value4', 'key2': 'value5', 'key3': 'value6'} 딕셔너리는 update() 함수를 통해 추가, 수정도 가능하네요. Mutable - 삭제리스트123456789101112list_sample = [1, 2, 3, 4, 5]del list_sample[1]print(list_sample)list_sample = [1, 2, 3, 4, 5]list_sample.pop(0)print(list_sample)list_sample = [1, 2, 3, 4, 5]list_sample.pop()print(list_sample)list_sample = [1, 2, 3, 4, 5]list_sample.remove(3)print(list_sample) [1, 3, 4, 5] [2, 3, 4, 5] [1, 2, 3, 4] [1, 2, 4, 5] del, pop() 함수는 index 를 통해서 삭제한다는 것과 remove() 함수는 요소 값을 삭제하는 것 그리고 pop() 인덱스 값을 넣지 않을 경우 가장 끝에 요소를 지운다는 것을 짚고 넘어가면 좋을 것 같습니다. 셋12345set_sample = {6, 7, 8, 9, 10}set_sample.remove(7)print(set_sample)set_sample.clear()print(set_sample) {6, 8, 9, 10} set() 셋도 마찬가지로 remove() 함수를 통해서 요소 값 자체를 삭제시키네요. clear() 함수는 요소를 모두 삭제시킬 수 있습니다. 딕셔너리1234567dict_sample = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}del dict_sample['key1']print(dict_sample)dict_sample.pop('key2')print(dict_sample)dict_sample.clear()print(dict_sample) {'key2': 'value2', 'key3': 'value3'} {'key3': 'value3'} {} 딕셔너리는 del, pop(), clear() 함수를 통해서 요소를 삭제시킬 수 있습니다. Immutable - 추가튜플의 경우 요소의 값을 변화시키는 것을 못할 뿐 뒤에 값을 더하는 것은 가능합니다. (리스트와 동일) 튜플1234set_sample1 = (1, 2, 3, 4, 5)set_sample2 = (6, 7, 8, 9, 10)set_sample3 = set_sample1 + set_sample2print(set_sample3) (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 결론정리해보겠습니다. 데이터를 핸들링하기 위해서 필수적으로 알아야 하는 데이터 자료형들의 특징에 대해서 알아봤습니다. 그리고 리스트, 튜플, 딕셔너리, 셋 에 대해서 순서 와 가변성 의 관점에서 각각의 기능(추가, 수정, 삭제) 들도 다뤄봤습니다. 이 내용은 여기서 끝이 아니라 앞으로 개발 하시면서 계속해서 다룰것들이니 내용 잘 정리해두시면 좋을 것 같습니다. 다음 포스팅은 조건문(if), 반복문(for, while) 주제에 대해서 다뤄보겠습니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference 점프 투 파이썬 https://wikidocs.net/14","link":"/2022/03/18/programming/python/python-03/"},{"title":"04. 제어문 (if, for, while)문","text":"안녕하세요 이전 포스팅 애서는 Pyhton 데이터들을 다루는데 있어서 4가지 형태 List, Tuple, Dictionary, Set 에 대해서 다뤄봤는데요. 이번 포스팅에서는 이러한 데이터들을 특정 조건에 따라 변환시키는 작업, 즉 데이터를 직접적으로 제어하는 방법에 대해서 얘기를 나눠보려고 합니다. if (조건문) while (반복문) for (반복문) if문굉장히 직관적이지 않나요. 보통은 반복문과 함께 쓰이기 때문에 한 가지 예시만 보고 빠르게 넘어가죠. if문 예시12345num = 4if num % 2 == 0: print(f'{num} - 짝수입니다')else: print(f'{num} - 홀수입니다.') 4은 짝수입니다 조건문 다음에는 항상 콜론 : 을 붙여서 구분을 해주는 것과 그리고 수행할 코드는 space 4 or 2칸의 Indent 를 준다는 것을 반드시 기억하기 바랍니다. num % 2 == 0 에서 %는 자료형과 연산 포스팅에서 보셨을 텐데요, 이 식은 짝수(2로 나눴을 때 나머지가 0)를 판별하는 조건식입니다. 여기서 == 연산자는 비교 연산자 중 하나인데요. (&lt;,&gt;,&lt;=,&gt;=,==,!=) 비교 연산자에 대해서 몇가지 재밌는(?) 예시를 짚고 넘어가겠습니다. 비교연산자 예시12345678910111213141516171819a = &quot;3&quot;b = &quot;4&quot;print(f&quot;'{a}' &gt; '{b}'의 결과는 {a &gt; b}&quot;)print(f&quot;'{a}' &lt; '{b}'의 결과는 {a &lt; b}&quot;)a = &quot;가&quot;b = &quot;나&quot;print(f&quot;'{a}' &gt; '{b}'의 결과는 {a &gt; b}&quot;)print(f&quot;'{a}' &lt; '{b}'의 결과는 {a &lt; b}&quot;)a = &quot;2022-03-20&quot;b = &quot;2021-03-19&quot;print(f&quot;'{a}' &gt; '{b}'의 결과는 {a &gt; b}&quot;)print(f&quot;'{a}' &lt; '{b}'의 결과는 {a &lt; b}&quot;)a = &quot;2022-23-20&quot;b = &quot;2022-03-19&quot;print(f&quot;'{a}' &gt; '{b}'의 결과는 {a &gt; b}&quot;)print(f&quot;'{a}' &lt; '{b}'의 결과는 {a &lt; b}&quot;) '3' &gt; '4'의 결과는 False '3' &lt; '4'의 결과는 True '가' &gt; '나'의 결과는 False '가' &lt; '나'의 결과는 True '2022-03-20' &gt; '2021-03-19'의 결과는 True '2022-03-20' &lt; '2021-03-19'의 결과는 False '2022-23-20' &gt; '2022-03-19'의 결과는 True '2022-23-20' &lt; '2022-03-19'의 결과는 False 얼핏 보면, String 타입의 ‘숫자’, ‘한글’, ‘날짜’ 가 마치 파이썬이 날짜와 숫자의 의미를 인식해서 비교를 하는 것처럼 보이지만, 사실은 그렇지 않습니다. 파이썬은 lexicographicaly 하게 비교 결과를 내뱉고 있는 것입니다(맨 밑 예시). 관련 글은 Reference에 적어두겠습니다. while문이제 반복문에 대해서 알아보겠습니다. 우선 예시를 하나 들어보죠. while문 예시1234num = 0while num &lt; 5: print(num) num += 1 0 1 2 3 4 여기서 num &lt; 5 는 while의 조건문 으로 들어갑니다. 해당 조건문이 참(True)일 때 밑에 식이 동작하는데요. 주의 하실게 만약 num += 1 줄이 없다면 무한loop 에 빠지게 됩니다. 사실 그렇기 때문에 특별히 신경을 써줘야 합니다. (그래서 저는 while 보다는 for문을 주로 사용합니다.) while문은 빠르게 넘어가겠습니다. for문에서 설명하고 싶은게 더 많거든요. for문for 문의 기본 형태부터 보도록 하겠습니다. for문 기본 형태 - 1. 리스트, 튜플, 딕셔너리, 셋12for 변수 in (리스트, 튜플, 딕셔너리, 셋): print(변수) for문 기본 형태 - 2. range() 함수 활용12for 변수 in range(5): print(변수) 0 1 2 3 4 먼저 for문과 많이 사용되는 range() 함수에 대해서 가볍게 정리해보고 넘어가겠습니다. range() parameter(start, stop, step)에 대한 설명12345678910111213for i in range(start, stop, step)- start: 시작할 숫자 - 생략 가능 (default=0) - 정수 입력- stop: 이전까지 반복 - 생략 불가 - 정수 입력- step: 반복시 i에 더할 값 (=보폭을 어떻게 할 것인가?) - 생략 가능 (default=0) - 정수 입력 (음수 입력시 역순으로 반복) 백문이불여일견! 몇가지 예시를 보고 빠르게 넘어가죠. range(start, stop, step) 간단 예시1234567891011for i in range(5): print(i)for i in range(1,5): print(i)for i in range(1,5,2): print(i)for i in range(5, 0, -1): print(i) for i in range(5) 0 1 2 3 4 for i in range(1,5) 1 2 3 4 for i in range(1,5,2) 1 3 for i in range(5, 0, -1) 5 4 3 2 1 그리고 리스트(List), 튜플(Tuple), 딕셔너리(Dictionary), 셋(set) 으로 이루어진 데이터를 for문으로 출력했을 때 어떤지 보면서 정리 한 번 하겠습니다. 리스트 for문1234list_sample = [1, 2, 3, 4, 5]for i in list_sample: print(i) 1 2 3 4 5 튜플 for문1234tuple_sample = (1, 2, 3, 4, 5)for i in tuple_sample: print(i) 1 2 3 4 5 셋 for문1234set_sample = {1, 2, 3, 4, 5}for i in set_sample: print(i) 1 2 3 4 5 딕셔너리 for문1234dict_sample = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}for i in dict_sample: print(i) key1 key2 key3 딕셔너리(Dictionary) 에 대한 for문을 잠시 보겠습니다. Dictionary 타입의 객체는 데이터를 조회하는데 몇가지 기능을 제공합니다. 한 번 보시죠. 딕셔너리(Dictionary) 함수 - get(), keys(), values(), items()1234dict_sample.get('key1') # key값으로 조회dict_sample.keys() # key값들만 가져오기dict_sample.values() # value값들만 가져오기dict_sample.items() # 한 쌍의 (key, value)를 리스트로 형변환 해서 가져오기 dict_sample.get('key1') -&gt; value1 dict_sample.keys() -&gt; dict_keys(['key1', 'key2', 'key3']) dict_sample.values() -&gt; dict_values(['value1', 'value2', 'value3']) dict_sample.items() -&gt; dict_items([('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')]) 그러면 딕셔너리의 items() 함수를 사용해서 for문을 통해 key, value 를 동시에 출력해보겠습니다. for문 - 딕셔너리 items() 예시12345for k,v in dict_sample.items(): print(k, v)for item in dict_sample.items(): print(item, item[0], item[1]) key1 value1 key2 value2 key3 value3 ('key1', 'value1') key1 value1 ('key2', 'value2') key2 value2 ('key3', 'value3') key3 value3 여기서 for 와 in 사이에 들어가는 변수는 반복할 데이터의 특징에 따라 상황에 맞게 핸들링할 수 있다는 것 기억해두시기 바랍니다. (+ 어떤 변수명을 쓰던지 개발자 마음이니 변수 네이밍은 개발자의 마음입니다.) for문 좀 더 활용하기 - zip, enumerate, break, continue자, 그러면 이제 for문에서 몇가지 좀 더 고급(?)기능들을 살펴보겠습니다. zip우선 zip에 대해서 알아보겠습니다. zip은 여러 2개이상의 데이터들을 동시에 for문에 돌릴 때 사용합니다. for문 - zip 예시123456789list_sample = [1, 2, 3, 4, 5, 6]tuple_sample = (1, 2, 3, 4, 5)set_sample = {1, 2, 3, 4, 4}for _l, _t, _s in zip(list_sample, tuple_sample, set_sample): print(_l, _t, _s)for _z in zip(list_sample, tuple_sample, set_sample): print(_z, _z[0], _z[1], _z[2]) 1 1 1 2 2 2 3 3 3 4 4 4 (1, 1, 1) 1 1 1 (2, 2, 2) 2 2 2 (3, 3, 3) 3 3 3 (4, 4, 4) 4 4 4 여기서 한 가지. list_sample의 길이는 6인데 출력되는 것은 길이가 제일 짧은 데이터(set_sample)를 기준으로 반복 한다는 것입니다. enumerateenumerate의 경우 for문 도는 것에 대해서 자체적으로 index를 생성해주는 기능입니다. 예시 보겠습니다. for문 - enumerate 예시1234567list_sample = [1, 2, 3, 4, 5]for idx, i in enumerate(list_sample): print(idx, i)for idx, item in enumerate(dict_sample.items()): print(idx, item) 0 1 1 2 2 3 3 4 4 5 0 ('key1', 'value1') 1 ('key2', 'value2') 2 ('key3', 'value3') 나중에 데이터를 핸들링 하실 때 해당 데이터의 index 값을 동시에 활용할 수 있는 것은 굉장히 유용하니 반드시 기억해두시기 바랍니다. continue반복문을 사용하다보면, 특정 조건에 맞으면 더이상 반복을 중단하고 싶을 때가 생깁니다. 리소스를 절약하는 차원에서 그렇죠. 반복문을 중단하는 방법에는 2가지가 있는데요. 그 두가지의 차이를 한 번 보겠습니다. continue 예시12345for j in range(5): if j == 2: continue print('특정 ) print(f&quot;j={j}&quot;) j=0 j=1 j=3 j=4 위 코드를 보면 if j == 2 라는 조건일 때 continue 를 작성했습니다. 그 결과 조건을 충족하면 그 밑에 코드들을 더이상 실행하지 않는다 는 것 확인할 수 있습니다. breakbreak 예시1234for j in range(5): if j == 2: break print(f&quot;j={j}&quot;) j=0 j=1 break의 경우 조건을 충족하면 더이상 반복을 하지 않는다 는 것을 확인할 수 있습니다. 결론이번 포스팅에서는 조건문(if), 반복문(while, for)에 대해서 알아봤는데요. remind 해보겠습니다. 조건문, 반복문에서 끝은 항상 콜론(:) 을 붙여주고 그 뒤에 작동하는 코드는 space 4 or 2 칸의 Indent 를 넣어준다 for문은 리스트, 튜플, 딕셔너리, 셋의 데이터 타입 모두 사용이 가능하다. for 와 in 사이의 변수의 이름은 개발자 마음대로 작성하며, 데이터의 형태에 따라 인자를 설정할 수 있다. (ex) for i,v in enumcerate(sample_list): for문에서는 zip, enumerate, continue, break 등의 몇가지 유용환 활용 기능들이 존재한다. 여기까지 정리하겠습니다. 꼭 반드시 암기할 필요는 없습니다. ‘이러한 기능이 존재한다’만 기억해두고 필요할 때 구글링해서 코딩하는게 국룰 이니까요. (물론 제생각…) 다음 포스팅은 함수 정의 에 대해서 얘기해보겠습니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference Compare string date in Python https://stackoverflow.com/questions/31350373/comparing-date-strings-in-python","link":"/2022/03/20/programming/python/python-04/"},{"title":"06. 클래스(Class)와 객체지향 다루기","text":"안녕하세요 이전 포스팅 애서는 Pyhton 코드를 작성할 때 반복적인 작업, 기능 등을 수행하는 단위를 함수로 정의해서 다루는 것에 대해서 얘기를 나눠봤는데요. 이번 포스팅에서는 정말 중요한 객체 지향 프로그래밍(Object-Oriented Programming), 클래스(Class)와 객체(Object) 의 개념 그리고 실제 이것을 구현하는 방법에 대해서 다뤄보려고 합니다. 객체 지향 프로그래밍 클래스와 인스턴스 객체 지향 프로그래밍늘 강조하는 것이지만, 객체 지향 프로그래밍이 왜(Why) 중요한지 그리고 무엇(What) 을 객체 지향 프로그래밍이라고 하는지에 대해서 잠시 짚고 넘어가도록 하겠습니다. 정의 컴퓨터 프로그래밍의 패러다임 중 하나로, 필요한 데이터를 추상화 시켜 속성(Attribute) 과 행위(Behavior) 를 가진 객체 를 최소한의 단위 로 만들고, 이러한 객체들 간의 유기적인 상호작용 을 할 수 있도록 로직 을 구성하는 프로그래밍 방법 여기에서 추상화 와 최소한의 단위 표현에 대해서 애매하게 다가오실 수 있을 것 같은데요. 좀 더 설명 드리자면, 추상화 란, 공통의 속성이나 기능을 묶어 이름을 붙이는 것 을 뜻하는데요. 예를 들면, ‘사자’, ‘호랑이’, ‘표범’ 들을 ‘육식동물’ 이라고 묶어서 이름을 붙이는 것이죠. 프로그래밍 관점에서는 ‘클래스를 만들고 설계하는 것 자체’를 뜻합니다. 최소한의 단위 라고 표현한 이유는 이전 클린코드 작성법 에서 함수를 설계할 때 최소한의 기능 단위로 정의를 하는 것이 좋다고 설명드렸습니다. 이러한 방식은 우리가 클래스(Class)를 정의하는 것에도 비슷하게 적용됩니다. 우선 결합도 와 응집도 에 대한 개념을 잠시 짚어 보겠습니다. 결합도 란, 모듈(클래스, 함수) 간의 상호 의존 정도를 나타내는 지표를 뜻합니다 =&gt; 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어 객체의 재사용 및 유지보수가 용이해집니다. 응집도 란, 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성을 뜻합니다 =&gt; 응집도가 높은 모듈은 하나의 책임(기능 수행)에 집중하고 독립성이 높아져, 재사용 및 유지보수가 용이해집니다. 즉 좋은 객체 지향 설계는 결합도는 낮추고 응집도는 높이는 것 입니다. 하지만, 이렇게 객체 지향적인 코딩을 하다보면 이 둘은 트레이드오프(trade-off)관계라는 것을 알 수 있을 텐데요. 그래서 저는 이 둘의 트레이드오프를 잘 조절한 것을 최소한의 단위 로 표현한 것입니다. 지금 당장은 와닿지 않는 표현들이라 생각됩니다. 지금 당장은 아니더라도 앞으로 코딩을 하면서 차차 알아가실 내용이기에 이쯤에서 정리하도록 하죠. 장,단점객체 지향 프로그래밍 설계의 장,단점 당연한 얘기겠지만 빠르게 정리하고 넘어가죠 장점 코드 재사용이 용이 유지보수가 쉬움 복잡한, 대형 프로젝트에 필수적 단점 설계시 많은 시간과 노력이 필요 사실 단점을 적기에도 애매합니다. 객체 지향 설계는 이제는 필수에 가까우며, 당연히 알아야할 개념이자, 앞으로 우리가 코딩을 할 때 지향해야할 것이라고 감히 말씀드리고 싶습니다. 정리해보면...우리가 어떤 어플리케이션을 개발할 때 모듈, 단위, 기능에 맞춰서 여러 클래스(Class)들을 정의하며(객체를 생성하며) 여기서 객체들은 각각이 수행하는 역할이 있을 것이고(응집도), 객체간 상호작용을 히먀 의존성을 가지게 되는데(결합도) 이러한 응집도와 결합도 라는 것은 트레이드오프 관계에 있어 결합도는 최소화하고 응집도는 최대화 하는 단위를 적절히 배분하여 설계하는 것이 좋은 객체 지향 프로그래밍이라 할 수 있는 것입니다. 클래스(Class) 와 인스턴스(Instance)클래스와 인스턴스그러면 클래스와 인스턴스 차이를 알아보겠습니다. 코드를 보면 바로 이해가 되실 것 같습니다. 클래스와 인스턴스 예시123456789class User: def __init__(self, name): self.name = name def say_hello(self): print(f&quot;안녕하세요. {self.name} 입니다!&quot;)user1 = User(&quot;대환&quot;)user2 = User(&quot;우현&quot;) 간단합니다. 우리가 함수를 정의할 때 앞에 def를 사용해서 정의했듯이, 클래스를 정의할 때 앞에 class를 사용해 정의합니다. 그래서 User는 클래스가 되는 것이구요. user1, user2는 인스턴스 입니다. 글로 정리해보면, 클래스(Class) : 속성(Attribute) 과 행위(Behavior) 를 변수(Variable)와 함수(Function)로 정의한 것 인스턴스(Instance): 클래스에서 정의한 것을 토대로 실제 메모리에 할당 된 것 이렇게 정리할 수 있겠네요. Tip! 파이썬에서 클래스(Class)를 네이밍 할 때 PascalCase 로 작성합니다. ex) ClassName, BertTokenizer 자, 위 예시에서 __init__, self 에 대해서 궁금하실 것 같은데요. __init____init__ 메서드는 클래스 생성시 자동으로 호출되는데, 우선 __init__ 이 없을 때를 보면, __init__ 메서드가 없을 때 객체 속성을 지정하는 방법1234567class User: def initialize(self, name): self.name = nameuser1 = User()user1.initialize(&quot;대환&quot;)print(user1.name) 대환 __init__ 메서드가 있다면123456class User: def __init__(self, name): self.name = nameuser1 = User(&quot;대환&quot;)print(user1.name) 대환 __init__ 메서드가 있으면 객체를 생성할 때 넘겨주면 되므로 훨씬 간단해지죠. 이러한 장점 때문에 보통 클래스를 만들 땐 항상 __init__ 메서드를 같이 정의해줍니다. __str____init__ 에 대해서 알아본 김에 __str__ 도 빠르게 짚고 넘어가죠. 인스턴스를 print()했을 때 원하는 값이 나오게 하려면 str 메서드를 사용할 수 있다. __str__ 메서드가 있다면123456789class User: def __init__(self, name): self.name = name def __str__(self): return f&quot;안녕하세요 저의 이름은 {self.name} 입니다.&quot;user1 = User(&quot;대환&quot;)print(user1) 안녕하세요 저의 이름은 대환 입니다. Tip! 클래스(Class) 내부의 함수는 메서드라는 표현을 사용한다. 위 예시에서 say_hello, initialize 를 메서드라 부른다. self인스턴스가 메서드를 호출할 때 자기 자신이 항상 첫번째 인자로 들어가는데 예시와 그림을 보겠습니다. self의 의미12345678910111213141516class User: def __init__(self, name, email): self.name = name self.email = email def __str__(self): return f&quot;이름은 {self.name} 이고, 이메일은 {self.email} 입니다.&quot; def change_info(self, new_name, new_email): self.name = new_name self.email = new_emailuser1 = User('대환', 'daehwan@example.com')print(user1)user1.change_info('대퐝', 'daefwang@example.com')print(user1) 이름은 대환 이고, 이메일은 daehwan@example.com 입니다. 이름은 대퐝 이고, 이메일은 daefwang@example.com 입니다. 이렇게 인스턴스가 메서드를 호출할 땐 자기 자신이 첫번째 인자로 넘어가기 때문에 메서드를 정의할 때 첫 파라미터로 self 를 넣어주는 것이죠. 꼭 self 가 아니라 다른 것을 사용해도 되지만 파이썬 개발자 간의 관례, 규칙이므로 self 라고 사용해주는 것이 좋습니다. 상속(Inheritance)과 오버라이딩(Overriding)상속(Inheritance)상속은 우리가 일상생활에서 사용하는 상속이라는 의미로 생각하시면 좋을 것 같습니다. 클래스로 비유하면, 다른 클래스의 기능, 변수 등을 새로운 클래스에 상속, 물려받도록 하는 것이죠. 코드 보겠습니다. CalculatorBasic 클래스 정의12345678910111213class CalculatorBasic: def __init__(self): pass def sum(self, num1, num2): return num1 + num2 def sub(self, num1, num2): return num1 - num2cal_basic = CalculatorBasic()print(cal_basic.sum(10, 2))print(cal_basic.sub(10, 2)) 12 8 CalculatorBasic을 상속받은 CalculatorHard 정의12345678910111213class CalculatorHard(CalculatorBasic): def mul(self, num1, num2): return num1 * num2 def div(self, num1, num2): return num1 / num2cal_hard = CalculatorHard()print(cal_hard.sum(10, 2))print(cal_hard.sub(10, 2))print(cal_hard.mul(10, 2))print(cal_hard.div(10, 2)) 12 8 20 5.0 위 예시를 보면 상속 의 의미를 확실히 이해하셨을 것 같습니다. CalculatorHard 를 정의할 때 sum, sub 메서드를 정의하지 않았음에도 사용할 수 있는 이유는 CalculatorBasic 클래스의 기능을 상속 받았기 때문이죠. 여기서 CalculatorBasic 은 부모클래스(Super Class), CalculatorHard 는 자식클래스(Sub Class)가 되는 것 입니다. 오버라이딩 (Overriding)그러면 오버라이딩에 대해서도 알아보죠. 코드 보겠습니다 1234567891011121314151617class CalculatorHard(CalculatorBasic): def sum(self, num1, num2): print(super().sum(num1, num2)) return f'오버라이딩 된 sum: {num1+num2}' def mul(self, num1, num2): return num1 * num2 def div(self, num1, num2): return num1 / num2cal_hard = CalculatorHard()print(cal_hard.sum(10, 2))print(cal_hard.sub(10, 2))print(cal_hard.mul(10, 2))print(cal_hard.div(10, 2)) 12 오버라이딩 된 sum: 12 8 20 5.0 보시는 것처럼 CalculatorHard에서 sum 이라는 함수를 다시 정의했죠. 그리고 기능을 물려준 클래스를 SuperClass 라고 얘기했는데요. super().sum() 을 하게되면 CalculatorBasic의 sum()을 사용할 수 있습니다. 추가로 알아둡시다! 결론이번 포스팅에서는 객체 지향 프로그래밍이 무엇 인지, 그리고 어떻게 설계하는 것이 좋은 것인지에 대해서도 얘기를 나눠봤습니다. 그리고 클래스를 정의하는 방법과 그리고 ___init___, self 에 대한 개념을 잠시 짚고 넘어갔구요. 마지막으로 클래스 상속과 오버라이딩에 대해서 알아봤습니다. 다음 포스팅에서는 캡슐화에 대한 얘기, 그리고 (_, __) 가 파이썬에서 어떤 의미를 가지는지에 대해서 얘기를 나눠보겠습니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference 위키독스-클래스 https://wikidocs.net/28 객체 지향 프로그래밍이 뭔가요?(블로그) https://jeong-pro.tistory.com/95 파이썬 객체지향(OOP) 블로그 https://velog.io/@kpl5672/파이썬-객체지향-저리#chapter-1-객체-지향-프로그래밍-시작하기","link":"/2022/04/02/programming/python/python-06/"},{"title":"Intro. 왜 파이썬일까?","text":"안녕하세요. 블로그를 시작하고 처음 작성하는 포스팅인데요. 처음 작성하는 주제는 Python 에 대해서 다뤄볼까 합니다. 아무래도 제가 처음 코딩을 접했던 ‘프로그래밍 언어’가 Python 이기도 하고요. 또 우연히 대학교 학부시절에 활동했던 동아리에 현재 활동하는 학생들을 대상으로 간단한 강의를 해야할 기회가 생겨 강의안을 만들겸 개념을 정리해볼까 합니다! (Python 3.7.11 기준) **Python**은 무엇일까요? 사실 이 질문에 대한 답은 설명하기 식상하게 느껴질 정도로 많은 분들이 정리를 너무나도 잘 해주셨습니다...(파이썬 언어의 창시자는 귀도 반 로섬이며, OS에 독립적으로 작동하며, 객체 지향적 언어(OOP) 이다. 또한 개발자 친화적이여서 코드가 간단하고 누군가 만들어 놓은 라이브러리를 쉽게 가져다 쓸 수 있는 장점이 있다 등등…) 그래서 이번 포스팅에 대해서는 조금은 다른 얘기를 해보려고 합니다. 질문을 바꿔보겠습니다. “왜 Python 을 배우려고 하시나요?” 요즘따라 주변 지인, 친구들로부터 이런 질문을 많이 받는 것 같은데요. “요즘 코딩 안하면 안될 것 같은데 파이썬이 뭐야?” “파이썬 공부하려는데 강의 추천좀 해줘” “파이썬 할 줄 알면 취업에 도움이 좀 되나?” … 보통 직장을 다니고 계시는 선배님이나 지인들은 “본인이 하고 있는 업무를 좀 더 효율적으로 바꿔볼 수 있을지 혹은 현재 업무 루틴에서 새로운 아이템을 추가해보기 위해서”, 취업 준비를 하거나 커리어 전환을 준비하시는 분들은 “요즘 핫한 언어이기 때문에” 라고 얘기를 하더라구요. 사실 전부 맞는 말입니다. Python 언어는 실제로 업무를 ‘자동화’해서 업무를 효율적으로 만들 수 있고, 또는 데이터를 가지고서 새롭게 ‘모델링’도 건드려볼 수 있구요, 마지막으로 실제로 ‘핫한 언어’ 가 맞기 때문이죠. 그러면 다시 물어보죠. 직장에 다니고 계신 분들에게는 업무의 효율성을 높이기 위한 것이 반드시 코딩을 해야 하는 것인지? 코딩을 해야 한다면, 반드시 파이썬이어야 하는지? 취업 또는 커리어 전환을 준비하고 계신 분들에게는 파이썬으로 무엇을 하고 싶은지? 어떤 직무를 생각하는지? 사실 모범 답안이 정해져 있는 것은 아닙니다 절대로...! 하지만 감히 이렇게 얘기는 할 수 있을 것 같습니다. 만약 Data Handling 이 그 이유에 대한 설명으로 들어가신다면, Python 을 공부한다면 좋을 것 같습니다. (물론 Data Volume에 따라 단순히 엑셀로도 할 수 있고, 유형에 따라 Google Analytics를 공부해야할 수도 있습니다... 따져봐야 겠지만...) 조금 더 자료를 가져와보면… StackOverFlow Trend 인데요. (아마 개발을 하시는 분들이라면 대부분 아실만한… 개발자들 사이에서 Q&amp;A 커뮤니티 속 태그(Tag) 사용을 기반으로 측정한 것입니다.) 데이터를 핸들링하는 대표적인 언어라 할 수 있는 Python, SAS, R 에 대한 트랜드 인데요. 이것 또한 그 이유중 하나일 수 있습니다. 실제로 프로그래밍 언어공부를 시작하는 시점에서 어떤 언어를 공부할지 고민을 하는데 있어서 그 언어의 커뮤니티가 얼마나 활성화 되어있는지, 그리고 Documents 가 상세하게 잘 작성되어 있는지 등의 여부도 상당히 중요하기 때문입니다. 그리고 파이썬을 기반으로 한 웹 프레임워크(DJango, Flask, FastAPI) 등도 탄탄하기에 프론트와 통신하는 백앤드 서버로도 개발이 용이합니다.(거의 만능임...) (이 내용은 다른 포스팅 주제에서 더 자세히 다뤄보겠습니다!) 이정도면 왜 Python 일까? 에 대한 답이 되었을까요? 결론 이번 포스팅에서는 Python 주제 포스팅 시작으로 서론이 길었는데요. 저는 항상 무언가를 시작할 때 왜(why) 라는 질문에 대해 스스로가 설명이 되어야 동기부여도 생기고 집중력이 생기더라구요. Data Handling &amp; Machine Learning 등이 필요하고 관심이 있으시다면, Python 언어를 공부하시는 것을 감히 추천합니다. 그럼 다음 Python 주제로는 Python 기초 부터 시작하도록 하겠습니다!!! 이상으로 이번 포스팅은 마치겠습니다. 개발 관련 공부를 할 수록 어렵고, 더더욱 고개가 숙여지네요...! 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다!","link":"/2022/03/14/programming/python/python-intro/"},{"title":"05. 함수(Function) 다루기","text":"안녕하세요 이전 포스팅 애서는 Pyhton 데이터들을 다룰 때 유용한 반복문(for, while)과 조건문(if)에 대해서 얘기를 나눠봤는데요. 이번 포스팅에서는 프로그래밍의 꽃(?)이라 할 수 있는 함수 정의에 대해서 얘기해보려고 합니다. 함수(Function) 정의하기 Parameter vs Arguments 짚고 넘어가기 lambda 다뤄보기 함수(Function) 정의하기왜(Why)?먼저 바로 함수 작성하는 방법을 설명드리기전에 왜(why) 함수를 사용하는지부터 얘기해보죠. 간결한 코드 작성이 용이해진다. 한 번 작성한 함수는 재사용이 가능하다. 가독성, 코드 유지관리가 쉬워진다. 등… 사실 함수를 사용하면 정말 많은 장점이 존재합니다. 그리고 그 장점 끝에는 “코드 작성자 &amp; 팀원과 공유할 때 커뮤니케이션이 원활해진다.” 로 이어집니다. 그럼 이제 본격적으로 함수를 어떻게 작성하는지부터 얘기를 해보겠습니다. 함수 작성법파이썬에서는 함수를 정의할 때 다음과 같이 정의합니다. 함수 정의 예시123def add(x, y): result = x+y return result 여기서 def 는 define(정의하다) 의 앞 글자를 딴 것인데요. 그리고 add는 우리가 정의한 함수의 이름 이 됩니다. 그리고 조건문, 반복문과 같이 함수명 뒤에 콜론(:) 그리고 indent를 해준 뒤 이 함수가 수행할 코드를 입력 한 후, 그 결과를 return(반환) 하는 구조입니다. 즉, 정의한 함수 add 는 두 변수(x,y)를 받아서 더한 값을 반환하는 함수 입니다. Parameter vs Arguments 짚고 넘어가기Parameter와 Arguments의 차이에 대해서 잠깐 짚고 넘어가겠습니다. Parameter(매개변수)와 Arguments(인수)의 구분123456def add(x, y): result = x+y return resultz = add(3,4)print(z) 7 간단합니다. Parameter는 함수를 정의할 때 입력으로 전달받는 변수를 의미하고, Arguments는 함수를 사용(호출)할 때 입력되는 값을 의미합니다. 즉, 위 예시코드에서 x,y는 Parameter(매개변수) 이고, 3, 4는 Arguments(인수) 가 되는 것이죠. Lambda 다뤄보기우리는 Lambda 를 통해 이름이 없는 함수를 만들 수 있습니다. 이름이 없다(?) 이해가 안가실 텐데요. 예시 보겠습니다. Lambda 예시12345678910def add(x, y): result = x+y return resultprint(add(3,4))no_name = lambda x, y: x + yprint(no_name(3,4))print((lambda x, y: x + y)(3,4)) 7 7 7 위 코드에서 lambda를 사용해서 add()와 같은 기능을 수행하는 함수를 정의했습니다. 7번째 줄 에서는 이름을 정하지 않았다는 것을 보여드리기 위해 임의로 no_name이라는 변수에 담아서 표현을 한 것입니다. 강조드리고 싶은 것은 10번째 줄 인데요. lambda를 사용하는 것에는 크게 2가지 장점이 있습니다. 간결한 코드를 작성할 수 있다. 메모리 절약 여기서 저는 장점 1번을 좀 더 강조드리고 싶은데요. 글로 설명할게 아니라 코드로 바로 보겠습니다. lambda 활용 예시 - sorted()sorted 험수는 list 타입의 객체에 내장되어 있는 함수 입니다. sorted() 함수 Description1234sorted(iterable, key=None, reverse=False)- iterable : A sequence (string, tuple, list) or collection (set, dictionary, frozen set) or any other iterator.- reverse (Optional) : If True, the sorted list is reversed (or sorted in descending order). Defaults to False if not provided.- key (Optional) : A function that serves as a key for the sort comparison. Defaults to sorted 함수 파라미터에 대한 설명을 보면, 파라미터 reverse 와 key 는 옵션으로 우리가 정의할 수 있는데요. 만약, 우리가 다루는 list 타입의 데이터를 문자열의 길이가 긴 것부터 정렬해야 한다면? 두가지 방식을 비교해 보겠습니다. def 로 함수를 정의했을 때1234567list_sample = ['a', 'bb', 'ccc', 'dddd', 'eeeee']def check_str_length(x): return len(x)new_list_sample = sorted(list_sample, key=check_str_length, reverse=True)print(new_list_sample) ['eeeee', 'dddd', 'ccc', 'bb', 'a'] lambda 로 함수를 정의했을 때1234list_sample = ['a', 'bb', 'ccc', 'dddd', 'eeeee']new_list_sample = sorted(list_sample, key=lambda x: len(x), reverse=True)print(new_list_sample) ['eeeee', 'dddd', 'ccc', 'bb', 'a'] 어떤가요? lambda를 사용했을 때 코드가 더 간결해진게 느껴지시나요? 다음 예시 보겠습니다. lambda 활용 예시 - map()map 함수는 sorted와 마찬가지로 iterable한 데이터를 받아서 각 요소마다 특정 동작을 수행할 수 있도록 해주는 함수입니다. map() 함수 Description123map(function, iterable, ...)- function : a function that perform some action to each element of an iterable- iterable : an iterable like sets, lists, tuples, etc 만약, 위 예시에서 사용했던 list_sample의 요소들을 각 길이값으로 바꿔야하면? 두가지 방식을 비교해 보겠습니다. def 로 함수를 정의했을 때12345678list_sample = ['a', 'bb', 'ccc', 'dddd', 'eeeee']def check_str_length(x): return len(x)new_list_sample = map(check_str_length, list_sample)print(new_list_sample)print(list(new_list_sample)) &lt;map object at 0x7fc0d1304590&gt; [1, 2, 3, 4, 5] lambda 로 함수를 정의했을 때12345list_sample = ['a', 'bb', 'ccc', 'dddd', 'eeeee']new_list_sample = map(lambda x: len(x), list_sample)print(new_list_sample)print(list(new_list_sample)) &lt;map object at 0x7fc0d12e28d0&gt; [1, 2, 3, 4, 5] 자 여기서 map() 함수가 반환한 것은 object of map class 즉, iterator 이기 떄문에 list()로 감싸주어 형변환을 해준뒤 출력한 것입니다. lambda 활용 예시 - filter()filter 함수의 경우 map함수와 가장 자주 비교되서 설명되는 함수입니다. 특정 조건으로 걸러진 요소들을 새롭게 객체로 만들어 반환 하는 함수입니다. filter() 함수 Description123filter(function, iterable- function : a function- iterable : an iterable like sets, lists, tuples, etc 위 예시들을 그대로 사용하겠습니다. 여기서는 길이가 3이상인 것들만 다시 반환하고 싶다면? 두가지 방식을 비교해 보겠습니다. def 로 함수를 정의했을 때1234567891011list_sample = ['a', 'bb', 'ccc', 'dddd', 'eeeee']def filter_three_len(x): if len(x) &gt;= 3: return x else: passnew_list_sample = filter(filter_three_len, list_sample)print(new_list_sample)print(list(new_list_sample)) &lt;filter object at 0x7fc0d09f80d0&gt; ['ccc', 'dddd', 'eeeee'] lambda 로 함수를 정의했을 때12345list_sample = ['a', 'bb', 'ccc', 'dddd', 'eeeee']new_list_sample = filter(lambda x: len(x) &gt;= 3, list_sample)print(new_list_sample)print(list(new_list_sample)) &lt;filter object at 0x7fc0d13c33d0&gt; ['ccc', 'dddd', 'eeeee'] 결론이번 포스팅에서는 함수 를 주제로 얘기를 해봤는데요. 먼저 어떻게 함수를 정의하는지 에 대해서 얘기를 해봤습니다. 그리고 Parameter, Arguments 차이에 대해서 잠깐 짚고 넘어갔구요. 그리고 일회성 함수로 사용하는 Lambda 작성하는 방법에 대해서 설명드렸습니다. 추가로 lambda 를 활용하는데 있어서 sorted(), map(), filter() 함수까지 알아봤습니다. 사실 위 함수들 같은 경우 for문 을 사용해서 똑같은 결과를 얻는 것 까지 다룰까 했지만, 이 부분은 각자 개인적으로 해보시면서 반복문과 함수에 대해서 개념을 정리해보시길 추천합니다. 이상으로 이번 포스팅은 마치겠습니다. 추가 의견이나 수정이 필요한 부분이 있다면 언제든지 거침없는 피드백 부탁드립니다! 부족한 글 읽어주셔서 감사합니다! Reference lambda https://wikidocs.net/22804 sorted https://www.programiz.com/python-programming/methods/built-in/sorted map https://www.programiz.com/python-programming/methods/built-in/map filter https://www.programiz.com/python-programming/methods/built-in/filter","link":"/2022/03/22/programming/python/python-05/"}],"tags":[{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Application","slug":"Application","link":"/tags/Application/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Front","slug":"Front","link":"/tags/Front/"},{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"hexo-icarus-theme","slug":"hexo-icarus-theme","link":"/tags/hexo-icarus-theme/"},{"name":"Category","slug":"Category","link":"/tags/Category/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Custom","slug":"Custom","link":"/tags/Custom/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"theme","slug":"theme","link":"/tags/theme/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Programming Language","slug":"Programming-Language","link":"/tags/Programming-Language/"},{"name":"Data Type","slug":"Data-Type","link":"/tags/Data-Type/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"log","slug":"Programming/log","link":"/categories/Programming/log/"},{"name":"Dart","slug":"Programming/Dart","link":"/categories/Programming/Dart/"},{"name":"Python","slug":"Programming/Python","link":"/categories/Programming/Python/"},{"name":"Basic","slug":"Programming/Python/Basic","link":"/categories/Programming/Python/Basic/"}],"pages":[{"title":"소개","text":"안녕하세요. Business 와 Full-Stack 을 지향하는 NLP(자연어처리)개발자 김대환 입니다. 저는 경영정보학과 를 전공하여 문과생입니다. 하지만 대학교 선배로부터 WalMart의 ‘맥주와 기저귀’ 와 머니볼 영화의 ‘세이버메트릭스’ 스토리에 대한 얘기를 들으면서 데이터 분석(Data Analysis) 의 꿈을 키웠습니다. 지금은 훌륭한 사람들과 함께 일하며 NLP개발 업무를 하며 많은 것을 배우고 있습니다. “나는 깊게 파기 위해 넓게 파기 시작했다.” - Benedict (Baruch) de Spinoza “나는 1만가지의 발차기를 한 번씩 연습한 상대는 두렵지 않다. 내가 두려워하는 것은 단 한 가지 발차기만 1만 번 반복해 연습한 상대를 만난 것이다.” - Bruce Lee 위의 두 어록은 현재 저의 삶의 모토(motto) 이자 블로그를 시작하게 된 계기 입니다. 현재 개발(코딩)업무를 하면서 코딩 뿐만 아니라 현업 분들과 커뮤니케이션을 하며 서비스를 만들어 가면서 많은 어려움도 느끼고 있습니다. 실제로 프론트개발도 해야 했으며, 실제 서비스될 화면도 디자인을 해야 했습니다. 팀원 모두 열심히 고민해보고 고생해서 만들었지만 현업으로부터 좋은 평가는 받지 못했었습니다. 이런 과정을 겪으면서 느꼈던 것은, “결국 ‘좋은 개발’이라는 것은 사람이 필요로 하는 것을 만들어 내는 것이며, 진정한 가치는 그 결과물을 사용자가 쓰면서 만족을 할 때 나타나는 것” 을 알았습니다. 그래서 좋은 개발 을 하기위해 여러 분야에 대해 공부하는 것을 두려워하지 말고 도전 하기로 마음을 먹었습니다. (깊게 파기 위해) 단, 수박 겉핥기 식으로 하지 않기 위해 많은 글을 찾고, 나의 글로 새롭개 정리해가며 지식으로 만들어 블로그에 기록을 하려고 합니다. (1만 번의 반복) 현재 많은 개발 블로거분들 덕분에 에러 디버깅에 많은 도움을 받고 있습니다. 저도 또 다른 누군가의 어려움에 조금이라도 도움이 되고자, 저의 경험이나 배웠던 것을 기록하고자 합니다. 혹시 틀린 부분이 있다면 서슴없이 지적해주시고 피드백 해주시면 감사하겠습니다! 앞으로 유익하고 좋은 글을 쓰도록 하겠습니다!!!","link":"/about/index.html"}]}